<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é€šçŸ¥ç³»ç»Ÿ API æµ‹è¯•å·¥å…· V2 - React</title>
    
    <!-- React and Babel from CDN -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: #f5f5f5;
            color: #333;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            border-radius: 10px;
            margin-bottom: 30px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            transition: background 0.3s ease;
        }
        
        .header.production {
            background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
        }
        
        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }
        
        .header p {
            opacity: 0.9;
            font-size: 1.1rem;
        }
        
        .warning {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        
        .warning.production {
            background: #f8d7da;
            border-color: #f5c6cb;
            color: #721c24;
        }
        
        .section {
            background: white;
            padding: 25px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }
        
        .section h2 {
            color: #667eea;
            margin-bottom: 20px;
            font-size: 1.8rem;
        }
        
        .form-group {
            margin-bottom: 20px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #555;
        }
        
        .form-group input, .form-group select, .form-group textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-size: 16px;
            transition: border-color 0.3s;
        }
        
        .form-group input:focus, .form-group select:focus, .form-group textarea:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .form-group textarea {
            min-height: 120px;
            resize: vertical;
            font-family: 'Consolas', 'Monaco', monospace;
        }
        
        .btn {
            display: inline-block;
            padding: 12px 24px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            margin-right: 10px;
            margin-bottom: 10px;
        }
        
        .btn:hover {
            background: #5a67d8;
            transform: translateY(-1px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }
        
        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .btn-primary {
            background: #667eea;
        }
        
        .btn-secondary {
            background: #6c757d;
        }
        
        .btn-danger {
            background: #dc3545;
        }
        
        .btn-danger:hover {
            background: #c82333;
        }
        
        .status-badge {
            display: inline-block;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 600;
        }
        
        .status-success {
            background: #d4edda;
            color: #155724;
        }
        
        .status-error {
            background: #f8d7da;
            color: #721c24;
        }
        
        .response-body {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 20px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 14px;
            white-space: pre-wrap;
            word-break: break-word;
            max-height: 500px;
            overflow-y: auto;
            position: relative;
        }
        
        .copy-button {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 5px 10px;
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            opacity: 0.7;
            transition: opacity 0.2s;
        }
        
        .copy-button:hover {
            opacity: 1;
        }
        
        .copy-button.copied {
            background: #28a745;
        }
        
        .json-key {
            color: #881391;
            font-weight: bold;
        }
        
        .json-string {
            color: #1a1aa6;
        }
        
        .json-number {
            color: #008080;
        }
        
        .json-boolean {
            color: #d73a49;
        }
        
        .json-null {
            color: #666;
        }
        
        .tab-nav {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
            flex-wrap: wrap;
        }
        
        .tab-btn {
            padding: 10px 20px;
            background: none;
            border: none;
            border-bottom: 3px solid transparent;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            color: #666;
            transition: all 0.3s;
        }
        
        .tab-btn.active {
            color: #667eea;
            border-bottom-color: #667eea;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .endpoint-info {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
            font-family: monospace;
        }
        
        .method-badge {
            display: inline-block;
            padding: 4px 8px;
            background: #28a745;
            color: white;
            border-radius: 4px;
            font-weight: bold;
            font-size: 14px;
            margin-right: 10px;
        }
        
        .method-badge.get {
            background: #007bff;
        }
        
        .method-badge.post {
            background: #28a745;
        }
        
        .method-badge.delete {
            background: #dc3545;
        }
        
        .quick-fill {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            flex-wrap: wrap;
        }
        
        .quick-fill button {
            padding: 6px 12px;
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .quick-fill button:hover {
            background: #5a6268;
        }
        
        .loader {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .channels {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        .channel-checkbox {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .channel-checkbox input[type="checkbox"] {
            width: auto;
            margin: 0;
        }
        
        .channel-checkbox label {
            margin: 0;
            font-weight: normal;
            cursor: pointer;
        }
        
        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        
        .data-table th, .data-table td {
            padding: 10px;
            border: 1px solid #ddd;
            text-align: left;
        }
        
        .data-table th {
            background: #f8f9fa;
            font-weight: 600;
        }
        
        .data-table tr:hover {
            background: #f8f9fa;
        }
        
        .action-btns {
            display: flex;
            gap: 5px;
        }
        
        .btn-sm {
            padding: 4px 8px;
            font-size: 14px;
        }
        
        .form-row {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .form-row .form-group {
            flex: 1;
            margin-bottom: 0;
        }
        
        .template-channel-item {
            border: 1px solid #e0e0e0;
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 6px;
            background: #f8f9fa;
        }
        
        .v2-badge {
            background: #17a2b8;
            color: white;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 12px;
            margin-left: 10px;
        }
        
        .remove-btn {
            float: right;
            background: #dc3545;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        
        .remove-btn:hover {
            background: #c82333;
        }
    </style>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useEffect, useCallback, useRef } = React;
        
        // API configuration
        const PRODUCTION_URL = 'https://notification.caas.xyz';
        
        // JSON ç¾åŒ–ç»„ä»¶
        function ResponseDisplay({ data }) {
            const [copied, setCopied] = useState(false);
            
            const handleCopy = async () => {
                try {
                    await navigator.clipboard.writeText(data || '');
                    setCopied(true);
                    setTimeout(() => setCopied(false), 2000);
                } catch (err) {
                    console.error('Failed to copy:', err);
                }
            };
            
            const formatJSON = (jsonString) => {
                if (!jsonString) return 'å“åº”ç»“æœå°†åœ¨è¿™é‡Œæ˜¾ç¤º...';
                
                try {
                    const obj = JSON.parse(jsonString);
                    return JSON.stringify(obj, null, 2);
                } catch {
                    return jsonString;
                }
            };
            
            return (
                <div className="response-body">
                    {data && (
                        <button 
                            className={`copy-button ${copied ? 'copied' : ''}`}
                            onClick={handleCopy}
                        >
                            {copied ? 'âœ“ å·²å¤åˆ¶' : 'å¤åˆ¶'}
                        </button>
                    )}
                    <pre style={{ margin: 0 }}>{formatJSON(data)}</pre>
                </div>
            );
        }

        // Main App Component
        function App() {
            const [activeTab, setActiveTab] = useState('send');
            const [environment, setEnvironment] = useState(() => {
                return localStorage.getItem('environment') || 'local';
            });
            const [apiSecret, setApiSecret] = useState(() => {
                const currentEnv = localStorage.getItem('environment') || 'local';
                if (currentEnv === 'production') {
                    return localStorage.getItem('api_secret_production') || '';
                } else {
                    return localStorage.getItem('api_secret_local') || 'test-secret-key-for-development';
                }
            });
            const [baseUrl, setBaseUrl] = useState(() => {
                const currentEnv = localStorage.getItem('environment') || 'local';
                return currentEnv === 'production' ? PRODUCTION_URL : window.location.origin;
            });
            const [response, setResponse] = useState({ data: null, status: null });
            const [loading, setLoading] = useState(false);
            const [requestHistory, setRequestHistory] = useState(() => {
                const saved = localStorage.getItem('request_history');
                return saved ? JSON.parse(saved) : [];
            });
            
            // Form states
            const [userId, setUserId] = useState('test-user');
            const [selectedChannels, setSelectedChannels] = useState(['webhook']);
            const [sendMethod, setSendMethod] = useState('custom');
            const [subject, setSubject] = useState('');
            const [content, setContent] = useState('è¿™æ˜¯ä¸€æ¡æµ‹è¯•é€šçŸ¥ ğŸ””');
            const [templateKey, setTemplateKey] = useState('');
            const [variables, setVariables] = useState('{}');
            const [idempotencyKey, setIdempotencyKey] = useState('');
            const [templates, setTemplates] = useState([]);
            const [templatesData, setTemplatesData] = useState({});
            
            // Handle environment change
            const handleEnvironmentChange = (env) => {
                if (env === 'production') {
                    if (confirm('âš ï¸ æ³¨æ„ï¼šæ‚¨å³å°†åˆ‡æ¢åˆ°æ­£å¼ç¯å¢ƒï¼\n\nè¯·ç¡®ä¿ï¼š\n1. ä½¿ç”¨æ­£ç¡®çš„æ­£å¼ç¯å¢ƒ API å¯†é’¥\n2. è°¨æ…æ“ä½œï¼Œé¿å…å‘é€æµ‹è¯•æ•°æ®\n\næ˜¯å¦ç»§ç»­ï¼Ÿ')) {
                        setEnvironment('production');
                        localStorage.setItem('environment', 'production');
                        setBaseUrl(PRODUCTION_URL);
                        const prodSecret = localStorage.getItem('api_secret_production') || '';
                        setApiSecret(prodSecret);
                    }
                } else {
                    setEnvironment('local');
                    localStorage.setItem('environment', 'local');
                    setBaseUrl(window.location.origin);
                    const localSecret = localStorage.getItem('api_secret_local') || 'test-secret-key-for-development';
                    setApiSecret(localSecret);
                }
            };
            
            // Generate signature
            const generateSignature = async (timestamp, body, secretKey) => {
                const encoder = new TextEncoder();
                const key = await crypto.subtle.importKey(
                    'raw',
                    encoder.encode(secretKey),
                    { name: 'HMAC', hash: 'SHA-256' },
                    false,
                    ['sign']
                );
                
                const signature = await crypto.subtle.sign(
                    'HMAC',
                    key,
                    encoder.encode(timestamp + body)
                );
                
                return Array.from(new Uint8Array(signature))
                    .map(b => b.toString(16).padStart(2, '0'))
                    .join('');
            };
            
            // Generate signature for GET/DELETE requests
            const generateGetSignature = async (timestamp, url, secretKey) => {
                const urlObj = new URL(url);
                const pathAndQuery = urlObj.pathname + urlObj.search;
                return generateSignature(timestamp, pathAndQuery, secretKey);
            };
            
            // Show response
            const showResponse = (data, status) => {
                const envInfo = environment === 'production' ? 
                    'âš ï¸ æ­£å¼ç¯å¢ƒå“åº”\n' + 'â”'.repeat(50) + '\n' : 
                    'âœ… æœ¬åœ°ç¯å¢ƒå“åº”\n' + 'â”'.repeat(50) + '\n';
                
                setResponse({
                    data: envInfo + JSON.stringify(data, null, 2),
                    status
                });
            };
            
            // Load templates
            const loadTemplates = useCallback(async () => {
                if (selectedChannels.length === 0) {
                    setTemplates([]);
                    return;
                }
                
                try {
                    const response = await fetch(baseUrl + '/api/templates');
                    const data = await response.json();
                    
                    if (data.success && data.data) {
                        const templatesMap = {};
                        data.data.forEach(template => {
                            templatesMap[template.template_key] = template;
                        });
                        setTemplatesData(templatesMap);
                        
                        // Filter templates that support all selected channels
                        const availableTemplates = data.data.filter(template => 
                            selectedChannels.every(channel => 
                                template.supported_channels && template.supported_channels.includes(channel)
                            )
                        );
                        
                        setTemplates(availableTemplates);
                        if (availableTemplates.length > 0) {
                            setTemplateKey(availableTemplates[0].template_key);
                        }
                    }
                } catch (error) {
                    console.error('Failed to load templates:', error);
                    setTemplates([]);
                }
            }, [selectedChannels, baseUrl]);
            
            // Send notification
            const sendNotification = async () => {
                setLoading(true);
                try {
                    const requestBody = {
                        user_id: userId,
                        channels: selectedChannels
                    };
                    
                    if (sendMethod === 'custom') {
                        requestBody.custom_content = {
                            content: content
                        };
                        if (subject) {
                            requestBody.custom_content.subject = subject;
                        }
                    } else {
                        requestBody.template_key = templateKey;
                        try {
                            const vars = JSON.parse(variables);
                            if (Object.keys(vars).length > 0) {
                                requestBody.variables = vars;
                            }
                        } catch (e) {
                            throw new Error('æ¨¡æ¿å˜é‡å¿…é¡»æ˜¯æœ‰æ•ˆçš„ JSON æ ¼å¼');
                        }
                    }
                    
                    if (idempotencyKey) {
                        requestBody.idempotency_key = idempotencyKey;
                    }
                    
                    const timestamp = Date.now().toString();
                    const body = JSON.stringify(requestBody);
                    const signature = await generateSignature(timestamp, body, apiSecret);
                    
                    // è°ƒè¯•ä¿¡æ¯
                    console.log('Request Debug Info:');
                    console.log('Timestamp:', timestamp);
                    console.log('API Secret:', apiSecret);
                    console.log('Body:', body);
                    console.log('Signature:', signature);
                    console.log('Payload for signature:', timestamp + body);
                    
                    const response = await fetch(baseUrl + '/api/notifications/send', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-Timestamp': timestamp,
                            'X-Signature': signature
                        },
                        body: body
                    });
                    
                    const data = await response.json();
                    showResponse(data, response.status);
                } catch (error) {
                    showResponse({ error: error.message }, 400);
                } finally {
                    setLoading(false);
                }
            };
            
            // Channel checkbox handler
            const handleChannelChange = (channel) => {
                setSelectedChannels(prev => {
                    if (prev.includes(channel)) {
                        return prev.filter(c => c !== channel);
                    } else {
                        return [...prev, channel];
                    }
                });
            };
            
            // Load templates when channels change
            useEffect(() => {
                if (sendMethod === 'template') {
                    loadTemplates();
                }
            }, [selectedChannels, sendMethod, loadTemplates]);
            
            // Tab components
            const tabs = {
                send: <SendNotificationTab 
                    userId={userId}
                    setUserId={setUserId}
                    selectedChannels={selectedChannels}
                    handleChannelChange={handleChannelChange}
                    sendMethod={sendMethod}
                    setSendMethod={setSendMethod}
                    subject={subject}
                    setSubject={setSubject}
                    content={content}
                    setContent={setContent}
                    templateKey={templateKey}
                    setTemplateKey={setTemplateKey}
                    templates={templates}
                    templatesData={templatesData}
                    variables={variables}
                    setVariables={setVariables}
                    idempotencyKey={idempotencyKey}
                    setIdempotencyKey={setIdempotencyKey}
                    sendNotification={sendNotification}
                    loading={loading}
                />,
                userconfig: <UserConfigTab baseUrl={baseUrl} showResponse={showResponse} apiSecret={apiSecret} generateGetSignature={generateGetSignature} generateSignature={generateSignature} />,
                templates: <TemplatesTab baseUrl={baseUrl} showResponse={showResponse} apiSecret={apiSecret} generateGetSignature={generateGetSignature} generateSignature={generateSignature} />,
                logs: <LogsTab baseUrl={baseUrl} showResponse={showResponse} apiSecret={apiSecret} generateGetSignature={generateGetSignature} generateSignature={generateSignature} />,
                health: <HealthTab baseUrl={baseUrl} showResponse={showResponse} />,
                metrics: <MetricsTab baseUrl={baseUrl} showResponse={showResponse} apiSecret={apiSecret} generateGetSignature={generateGetSignature} />,
                grafana: <GrafanaTab baseUrl={baseUrl} showResponse={showResponse} environment={environment} />
            };
            
            return (
                <div className="container">
                    <div className={`header ${environment === 'production' ? 'production' : ''}`}>
                        <h1>ğŸš€ é€šçŸ¥ç³»ç»Ÿ API æµ‹è¯•å·¥å…· <span className="v2-badge">V2 React</span></h1>
                        <p>æœ¬åœ°å¼€å‘ç¯å¢ƒä¸“ç”¨æµ‹è¯•ç•Œé¢ - æ”¯æŒå¤šæ¸ é“æ¨¡æ¿</p>
                    </div>
                    
                    <div className={`warning ${environment === 'production' ? 'production' : ''}`}>
                        {environment === 'production' ? (
                            <>ğŸš¨ <strong>æ­£å¼ç¯å¢ƒæ¨¡å¼ï¼š</strong>æ‚¨æ­£åœ¨å¯¹æ­£å¼ç¯å¢ƒè¿›è¡Œæ“ä½œï¼Œè¯·è°¨æ…ä½¿ç”¨ï¼æ‰€æœ‰æ“ä½œéƒ½ä¼šå½±å“çœŸå®ç”¨æˆ·ã€‚</>
                        ) : (
                            <>âš ï¸ <strong>æ³¨æ„ï¼š</strong>æ­¤ç•Œé¢ä»…åœ¨æœ¬åœ°å¼€å‘ç¯å¢ƒå¯ç”¨ï¼Œç”Ÿäº§ç¯å¢ƒä¼šè‡ªåŠ¨ç¦ç”¨ã€‚</>
                        )}
                    </div>
                    
                    <div className="section">
                        <h2>ğŸ”§ API é…ç½®</h2>
                        <div className="form-row">
                            <div className="form-group">
                                <label htmlFor="environment">ç¯å¢ƒé€‰æ‹©</label>
                                <select 
                                    id="environment" 
                                    value={environment}
                                    onChange={(e) => handleEnvironmentChange(e.target.value)}
                                >
                                    <option value="local">æœ¬åœ°å¼€å‘ç¯å¢ƒ</option>
                                    <option value="production">æ­£å¼ç¯å¢ƒ (notification.caas.xyz)</option>
                                </select>
                                <small style={{ color: environment === 'production' ? '#dc3545' : '#28a745' }}>
                                    {environment === 'production' ? 'å½“å‰ä½¿ç”¨æ­£å¼ç¯å¢ƒ API' : 'å½“å‰ä½¿ç”¨æœ¬åœ° API'}
                                </small>
                            </div>
                            <div className="form-group">
                                <label htmlFor="apiSecret">API å¯†é’¥</label>
                                <input 
                                    type="password" 
                                    id="apiSecret" 
                                    value={apiSecret}
                                    onChange={(e) => {
                                        const newSecret = e.target.value;
                                        setApiSecret(newSecret);
                                        // æ ¹æ®å½“å‰ç¯å¢ƒä¿å­˜å¯†é’¥
                                        if (environment === 'production') {
                                            localStorage.setItem('api_secret_production', newSecret);
                                        } else {
                                            localStorage.setItem('api_secret_local', newSecret);
                                        }
                                    }}
                                    placeholder={environment === 'production' ? 'è¾“å…¥æ­£å¼ç¯å¢ƒ API å¯†é’¥' : 'è¾“å…¥ API å¯†é’¥'}
                                />
                                <small style={{ color: environment === 'production' ? '#dc3545' : '#666' }}>
                                    {environment === 'production' ? 'è¯·è¾“å…¥æ­£å¼ç¯å¢ƒçš„ API å¯†é’¥' : 'é»˜è®¤ä½¿ç”¨ .dev.vars ä¸­çš„å¯†é’¥'}
                                </small>
                            </div>
                        </div>
                    </div>
                    
                    <div className="section">
                        <div className="tab-nav">
                            {Object.keys(tabs).map(tab => (
                                <button
                                    key={tab}
                                    className={`tab-btn ${activeTab === tab ? 'active' : ''}`}
                                    onClick={() => setActiveTab(tab)}
                                >
                                    {tab === 'send' && 'å‘é€é€šçŸ¥'}
                                    {tab === 'userconfig' && 'ç”¨æˆ·é…ç½®'}
                                    {tab === 'templates' && 'æ¨¡æ¿ç®¡ç† V2'}
                                    {tab === 'logs' && 'é€šçŸ¥æ—¥å¿—'}
                                    {tab === 'health' && 'å¥åº·æ£€æŸ¥'}
                                    {tab === 'metrics' && 'ç³»ç»ŸæŒ‡æ ‡'}
                                    {tab === 'grafana' && 'Grafana Webhook'}
                                </button>
                            ))}
                        </div>
                        
                        <div className="tab-content active">
                            {tabs[activeTab]}
                        </div>
                    </div>
                    
                    <div className="section response-section">
                        <div className="response-header">
                            <h2>ğŸ“¤ å“åº”ç»“æœ</h2>
                            {response.status && (
                                <div id="statusBadge">
                                    <span className={`status-badge ${response.status >= 200 && response.status < 300 ? 'status-success' : 'status-error'}`}>
                                        {response.status >= 200 && response.status < 300 ? 'æˆåŠŸ' : 'é”™è¯¯'} {response.status}
                                    </span>
                                </div>
                            )}
                        </div>
                        <ResponseDisplay data={response.data} />
                    </div>
                </div>
            );
        }
        
        // Send Notification Tab Component
        function SendNotificationTab(props) {
            const {
                userId, setUserId, selectedChannels, handleChannelChange,
                sendMethod, setSendMethod, subject, setSubject,
                content, setContent, templateKey, setTemplateKey,
                templates, templatesData, variables, setVariables,
                idempotencyKey, setIdempotencyKey, sendNotification, loading
            } = props;
            
            return (
                <>
                    <div className="endpoint-info">
                        <span className="method-badge post">POST</span>
                        <span>/api/notifications/send</span>
                    </div>
                    
                    <div className="form-group">
                        <label htmlFor="userId">ç”¨æˆ· ID *</label>
                        <input 
                            type="text" 
                            id="userId" 
                            value={userId}
                            onChange={(e) => setUserId(e.target.value)}
                            required 
                        />
                        <div className="quick-fill">
                            <button onClick={() => setUserId('test-user')}>æµ‹è¯•ç”¨æˆ·</button>
                            <button onClick={() => setUserId('demo-user')}>æ¼”ç¤ºç”¨æˆ·</button>
                            <button onClick={() => setUserId('rei')}>Rei (Lark)</button>
                            <button onClick={() => setUserId('user-' + Date.now())}>éšæœºç”¨æˆ·</button>
                        </div>
                    </div>
                    
                    <div className="form-group">
                        <label>é€šçŸ¥æ¸ é“ * <small>é€‰æ‹©ä¸€ä¸ªæˆ–å¤šä¸ªæ¸ é“</small></label>
                        <div className="channels">
                            {['webhook', 'telegram', 'lark', 'slack'].map(channel => (
                                <div key={channel} className="channel-checkbox">
                                    <input 
                                        type="checkbox" 
                                        id={`channel-${channel}`}
                                        value={channel}
                                        checked={selectedChannels.includes(channel)}
                                        onChange={() => handleChannelChange(channel)}
                                    />
                                    <label htmlFor={`channel-${channel}`}>
                                        {channel === 'webhook' && 'Webhook'}
                                        {channel === 'telegram' && 'Telegram'}
                                        {channel === 'lark' && 'é£ä¹¦/Lark'}
                                        {channel === 'slack' && 'Slack'}
                                    </label>
                                </div>
                            ))}
                        </div>
                    </div>
                    
                    <div className="form-group">
                        <label>å‘é€æ–¹å¼</label>
                        <select value={sendMethod} onChange={(e) => setSendMethod(e.target.value)}>
                            <option value="custom">è‡ªå®šä¹‰å†…å®¹</option>
                            <option value="template">ä½¿ç”¨æ¨¡æ¿</option>
                        </select>
                    </div>
                    
                    {sendMethod === 'custom' ? (
                        <>
                            <div className="form-group">
                                <label htmlFor="subject">ä¸»é¢˜ï¼ˆå¯é€‰ï¼‰</label>
                                <input 
                                    type="text" 
                                    id="subject" 
                                    placeholder="é€šçŸ¥ä¸»é¢˜"
                                    value={subject}
                                    onChange={(e) => setSubject(e.target.value)}
                                />
                            </div>
                            
                            <div className="form-group">
                                <label htmlFor="content">å†…å®¹ *</label>
                                <textarea 
                                    id="content" 
                                    placeholder="é€šçŸ¥å†…å®¹" 
                                    required
                                    value={content}
                                    onChange={(e) => setContent(e.target.value)}
                                />
                            </div>
                        </>
                    ) : (
                        <>
                            <div className="form-group">
                                <label htmlFor="templateKey">æ¨¡æ¿ Key</label>
                                <select 
                                    id="templateKey"
                                    value={templateKey}
                                    onChange={(e) => setTemplateKey(e.target.value)}
                                    disabled={templates.length === 0}
                                >
                                    {templates.length === 0 ? (
                                        <option value="">æ²¡æœ‰å¯ç”¨çš„æ¨¡æ¿</option>
                                    ) : (
                                        templates.map(template => (
                                            <option key={template.template_key} value={template.template_key}>
                                                {template.template_key} - {template.template_name}
                                                {template.description && ` (${template.description})`}
                                            </option>
                                        ))
                                    )}
                                </select>
                                <small>åªæ˜¾ç¤ºæ‰€æœ‰é€‰ä¸­æ¸ é“éƒ½æ”¯æŒçš„æ¨¡æ¿</small>
                            </div>
                            
                            <div className="form-group">
                                <label htmlFor="variables">æ¨¡æ¿å˜é‡ï¼ˆJSONï¼‰</label>
                                <textarea 
                                    id="variables" 
                                    placeholder='{"username": "å¼ ä¸‰", "date": "2024-01-01"}'
                                    value={variables}
                                    onChange={(e) => setVariables(e.target.value)}
                                />
                                {templateKey && templatesData[templateKey]?.variables && Array.isArray(templatesData[templateKey].variables) && (
                                    <div style={{ marginTop: '10px', color: '#666', fontSize: '14px' }}>
                                        éœ€è¦çš„å˜é‡: {templatesData[templateKey].variables.join(', ')}
                                    </div>
                                )}
                            </div>
                        </>
                    )}
                    
                    <div className="form-group">
                        <label htmlFor="idempotencyKey">å¹‚ç­‰é”®ï¼ˆå¯é€‰ï¼‰</label>
                        <input 
                            type="text" 
                            id="idempotencyKey" 
                            placeholder="ç”¨äºé˜²æ­¢é‡å¤å‘é€"
                            value={idempotencyKey}
                            onChange={(e) => setIdempotencyKey(e.target.value)}
                        />
                    </div>
                    
                    <button 
                        className="btn btn-primary" 
                        onClick={sendNotification}
                        disabled={loading || selectedChannels.length === 0}
                    >
                        {loading ? (
                            <>
                                <span className="loader" style={{ marginRight: '5px' }}></span>
                                å‘é€ä¸­...
                            </>
                        ) : (
                            'å‘é€é€šçŸ¥'
                        )}
                    </button>
                </>
            );
        }
        
        // User Config Tab Component
        function UserConfigTab({ baseUrl, showResponse, apiSecret, generateGetSignature, generateSignature }) {
            const [userId, setUserId] = useState('');
            const [configs, setConfigs] = useState([]);
            const [newConfig, setNewConfig] = useState({
                userId: '',
                channelType: 'webhook',
                configData: '{}'
            });
            
            const getUserConfigs = async () => {
                try {
                    const url = baseUrl + '/api/user-configs' + (userId ? `?user_id=${userId}` : '');
                    const timestamp = Date.now().toString();
                    const signature = await generateGetSignature(timestamp, url, apiSecret);
                    
                    const response = await fetch(url, {
                        headers: {
                            'X-Timestamp': timestamp,
                            'X-Signature': signature
                        }
                    });
                    const data = await response.json();
                    showResponse(data, response.status);
                    
                    if (data.success && data.data) {
                        setConfigs(data.data);
                    }
                } catch (error) {
                    showResponse({ error: error.message }, 400);
                }
            };
            
            const upsertUserConfig = async () => {
                try {
                    const configData = JSON.parse(newConfig.configData);
                    const requestBody = {
                        user_id: newConfig.userId,
                        channel_type: newConfig.channelType,
                        config_data: configData
                    };
                    
                    const timestamp = Date.now().toString();
                    const body = JSON.stringify(requestBody);
                    const signature = await generateSignature(timestamp, body, apiSecret);
                    
                    const response = await fetch(baseUrl + '/api/user-configs', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-Timestamp': timestamp,
                            'X-Signature': signature
                        },
                        body: body
                    });
                    
                    const data = await response.json();
                    showResponse(data, response.status);
                    
                    if (response.ok) {
                        getUserConfigs();
                    }
                } catch (error) {
                    showResponse({ error: error.message }, 400);
                }
            };
            
            const deleteUserConfig = async (userId, channelType) => {
                if (!confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªé…ç½®å—ï¼Ÿ')) return;
                
                try {
                    const timestamp = Date.now().toString();
                    const body = JSON.stringify({ user_id: userId, channel_type: channelType });
                    const signature = await generateSignature(timestamp, body, apiSecret);
                    
                    const response = await fetch(baseUrl + '/api/user-configs', {
                        method: 'DELETE',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-Timestamp': timestamp,
                            'X-Signature': signature
                        },
                        body: body
                    });
                    
                    const data = await response.json();
                    showResponse(data, response.status);
                    
                    if (response.ok) {
                        getUserConfigs();
                    }
                } catch (error) {
                    showResponse({ error: error.message }, 400);
                }
            };
            
            const setConfigTemplate = (type) => {
                const templates = {
                    webhook: {
                        webhook_url: "https://webhook.site/your-webhook-url"
                    },
                    telegram: {
                        bot_token: "YOUR_BOT_TOKEN",
                        chat_id: "YOUR_CHAT_ID"
                    },
                    lark: {
                        webhook_url: "https://open.feishu.cn/open-apis/bot/v2/hook/xxx",
                        secret: "YOUR_SECRET_KEY"
                    },
                    slack: {
                        webhook_url: "https://hooks.slack.com/services/xxx/xxx/xxx"
                    }
                };
                
                setNewConfig(prev => ({
                    ...prev,
                    channelType: type,
                    configData: JSON.stringify(templates[type], null, 2)
                }));
            };
            
            return (
                <>
                    <h3>æŸ¥è¯¢ç”¨æˆ·é…ç½®</h3>
                    <div className="form-group">
                        <label htmlFor="configUserId">ç”¨æˆ· IDï¼ˆå¯é€‰ï¼‰</label>
                        <input 
                            type="text" 
                            id="configUserId" 
                            placeholder="ç•™ç©ºæŸ¥è¯¢æ‰€æœ‰"
                            value={userId}
                            onChange={(e) => setUserId(e.target.value)}
                        />
                    </div>
                    <button className="btn btn-primary" onClick={getUserConfigs}>æŸ¥è¯¢é…ç½®</button>
                    
                    {configs.length > 0 && (
                        <table className="data-table">
                            <thead>
                                <tr>
                                    <th>ç”¨æˆ· ID</th>
                                    <th>æ¸ é“ç±»å‹</th>
                                    <th>é…ç½®æ•°æ®</th>
                                    <th>çŠ¶æ€</th>
                                    <th>æ“ä½œ</th>
                                </tr>
                            </thead>
                            <tbody>
                                {configs.map((config, index) => (
                                    <tr key={index}>
                                        <td>{config.user_id}</td>
                                        <td>{config.channel_type}</td>
                                        <td>
                                            <pre style={{ margin: 0, fontSize: '12px' }}>
                                                {JSON.stringify(config.config_data, null, 2)}
                                            </pre>
                                        </td>
                                        <td>{config.is_active ? 'âœ… æ¿€æ´»' : 'âŒ ç¦ç”¨'}</td>
                                        <td>
                                            <button 
                                                className="btn btn-danger btn-sm"
                                                onClick={() => deleteUserConfig(config.user_id, config.channel_type)}
                                            >
                                                åˆ é™¤
                                            </button>
                                        </td>
                                    </tr>
                                ))}
                            </tbody>
                        </table>
                    )}
                    
                    <hr style={{ margin: '30px 0' }} />
                    
                    <h3>åˆ›å»º/æ›´æ–°é…ç½®</h3>
                    <div className="form-row">
                        <div className="form-group">
                            <label htmlFor="newUserId">ç”¨æˆ· ID</label>
                            <input 
                                type="text" 
                                id="newUserId" 
                                placeholder="test-user"
                                value={newConfig.userId}
                                onChange={(e) => setNewConfig(prev => ({ ...prev, userId: e.target.value }))}
                            />
                        </div>
                        <div className="form-group">
                            <label htmlFor="newChannelType">æ¸ é“ç±»å‹</label>
                            <select 
                                id="newChannelType"
                                value={newConfig.channelType}
                                onChange={(e) => setNewConfig(prev => ({ ...prev, channelType: e.target.value }))}
                            >
                                <option value="webhook">Webhook</option>
                                <option value="telegram">Telegram</option>
                                <option value="lark">Lark</option>
                                <option value="slack">Slack</option>
                            </select>
                        </div>
                    </div>
                    
                    <div className="form-group">
                        <label htmlFor="newConfigData">é…ç½®æ•°æ®ï¼ˆJSONï¼‰</label>
                        <textarea 
                            id="newConfigData" 
                            placeholder='{"key": "value"}'
                            rows="8"
                            value={newConfig.configData}
                            onChange={(e) => setNewConfig(prev => ({ ...prev, configData: e.target.value }))}
                        />
                        <div className="quick-fill">
                            <button onClick={() => setConfigTemplate('webhook')}>Webhook æ¨¡æ¿</button>
                            <button onClick={() => setConfigTemplate('telegram')}>Telegram æ¨¡æ¿</button>
                            <button onClick={() => setConfigTemplate('lark')}>Lark æ¨¡æ¿</button>
                            <button onClick={() => setConfigTemplate('slack')}>Slack æ¨¡æ¿</button>
                        </div>
                    </div>
                    
                    <button className="btn btn-primary" onClick={upsertUserConfig}>ä¿å­˜é…ç½®</button>
                </>
            );
        }
        
        // Templates Tab Component
        function TemplatesTab({ baseUrl, showResponse, apiSecret, generateGetSignature, generateSignature }) {
            const [templates, setTemplates] = useState([]);
            const [newTemplate, setNewTemplate] = useState({
                templateKey: '',
                templateName: '',
                description: '',
                variables: '',
                channels: []
            });
            
            const getTemplates = async () => {
                try {
                    const url = baseUrl + '/api/templates';
                    const timestamp = Date.now().toString();
                    const signature = await generateGetSignature(timestamp, url, apiSecret);
                    
                    const response = await fetch(url, {
                        headers: {
                            'X-Timestamp': timestamp,
                            'X-Signature': signature
                        }
                    });
                    const data = await response.json();
                    showResponse(data, response.status);
                    
                    if (data.success && data.data) {
                        setTemplates(data.data);
                    }
                } catch (error) {
                    showResponse({ error: error.message }, 400);
                }
            };
            
            const addTemplateChannel = () => {
                setNewTemplate(prev => ({
                    ...prev,
                    channels: [...prev.channels, {
                        channelType: 'webhook',
                        contentType: 'text',
                        subjectTemplate: '',
                        contentTemplate: ''
                    }]
                }));
            };
            
            const removeTemplateChannel = (index) => {
                setNewTemplate(prev => ({
                    ...prev,
                    channels: prev.channels.filter((_, i) => i !== index)
                }));
            };
            
            const updateTemplateChannel = (index, field, value) => {
                setNewTemplate(prev => ({
                    ...prev,
                    channels: prev.channels.map((ch, i) => 
                        i === index ? { ...ch, [field]: value } : ch
                    )
                }));
            };
            
            const upsertTemplate = async () => {
                try {
                    const variables = newTemplate.variables ? 
                        newTemplate.variables.split(',').map(v => v.trim()).filter(v => v) : [];
                    
                    const requestBody = {
                        template_key: newTemplate.templateKey,
                        template_name: newTemplate.templateName,
                        description: newTemplate.description || undefined,
                        variables: variables.length > 0 ? variables : undefined,
                        channels: newTemplate.channels.map(ch => ({
                            channel_type: ch.channelType,
                            content_type: ch.contentType,
                            subject_template: ch.subjectTemplate || undefined,
                            content_template: ch.contentTemplate
                        }))
                    };
                    
                    const timestamp = Date.now().toString();
                    const body = JSON.stringify(requestBody);
                    const signature = await generateSignature(timestamp, body, apiSecret);
                    
                    const response = await fetch(baseUrl + '/api/templates', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-Timestamp': timestamp,
                            'X-Signature': signature
                        },
                        body: body
                    });
                    
                    const data = await response.json();
                    showResponse(data, response.status);
                    
                    if (response.ok) {
                        setNewTemplate({
                            templateKey: '',
                            templateName: '',
                            description: '',
                            variables: '',
                            channels: []
                        });
                        getTemplates();
                    }
                } catch (error) {
                    showResponse({ error: error.message }, 400);
                }
            };
            
            const deleteTemplate = async (templateKey) => {
                if (!confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªæ¨¡æ¿å—ï¼Ÿ')) return;
                
                try {
                    const url = baseUrl + '/api/templates';
                    const timestamp = Date.now().toString();
                    const body = JSON.stringify({ template_key: templateKey });
                    const signature = await generateSignature(timestamp, body, apiSecret);
                    
                    const response = await fetch(url, {
                        method: 'DELETE',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-Timestamp': timestamp,
                            'X-Signature': signature
                        },
                        body: body
                    });
                    
                    const data = await response.json();
                    showResponse(data, response.status);
                    
                    if (response.ok) {
                        getTemplates();
                    }
                } catch (error) {
                    showResponse({ error: error.message }, 400);
                }
            };
            
            useEffect(() => {
                getTemplates();
            }, []);
            
            return (
                <>
                    <h3>æ¨¡æ¿åˆ—è¡¨</h3>
                    <button className="btn btn-primary" onClick={getTemplates}>æŸ¥è¯¢æ¨¡æ¿</button>
                    
                    {templates.length > 0 && (
                        <table className="data-table">
                            <thead>
                                <tr>
                                    <th>æ¨¡æ¿ Key</th>
                                    <th>æ¨¡æ¿åç§°</th>
                                    <th>æè¿°</th>
                                    <th>å˜é‡</th>
                                    <th>æ”¯æŒæ¸ é“</th>
                                    <th>æ“ä½œ</th>
                                </tr>
                            </thead>
                            <tbody>
                                {templates.map(template => (
                                    <tr key={template.template_key}>
                                        <td>{template.template_key}</td>
                                        <td>{template.template_name}</td>
                                        <td>{template.description || '-'}</td>
                                        <td>{Array.isArray(template.variables) ? template.variables.join(', ') : '-'}</td>
                                        <td>{Array.isArray(template.supported_channels) ? template.supported_channels.join(', ') : '-'}</td>
                                        <td>
                                            <button 
                                                className="btn btn-danger btn-sm"
                                                onClick={() => deleteTemplate(template.template_key)}
                                            >
                                                åˆ é™¤
                                            </button>
                                        </td>
                                    </tr>
                                ))}
                            </tbody>
                        </table>
                    )}
                    
                    <hr style={{ margin: '30px 0' }} />
                    
                    <h3>åˆ›å»º/æ›´æ–°æ¨¡æ¿</h3>
                    <div className="form-row">
                        <div className="form-group">
                            <label htmlFor="newTemplateKey">æ¨¡æ¿ Key</label>
                            <input 
                                type="text" 
                                id="newTemplateKey" 
                                placeholder="welcome_email"
                                value={newTemplate.templateKey}
                                onChange={(e) => setNewTemplate(prev => ({ ...prev, templateKey: e.target.value }))}
                            />
                        </div>
                        <div className="form-group">
                            <label htmlFor="newTemplateName">æ¨¡æ¿åç§°</label>
                            <input 
                                type="text" 
                                id="newTemplateName" 
                                placeholder="æ¬¢è¿é‚®ä»¶"
                                value={newTemplate.templateName}
                                onChange={(e) => setNewTemplate(prev => ({ ...prev, templateName: e.target.value }))}
                            />
                        </div>
                    </div>
                    
                    <div className="form-group">
                        <label htmlFor="newTemplateDescription">æè¿°ï¼ˆå¯é€‰ï¼‰</label>
                        <input 
                            type="text" 
                            id="newTemplateDescription" 
                            placeholder="æ–°ç”¨æˆ·æ³¨å†Œæ¬¢è¿é‚®ä»¶æ¨¡æ¿"
                            value={newTemplate.description}
                            onChange={(e) => setNewTemplate(prev => ({ ...prev, description: e.target.value }))}
                        />
                    </div>
                    
                    <div className="form-group">
                        <label htmlFor="newTemplateVariables">æ¨¡æ¿å˜é‡ï¼ˆé€—å·åˆ†éš”ï¼‰</label>
                        <input 
                            type="text" 
                            id="newTemplateVariables" 
                            placeholder="username, email, date"
                            value={newTemplate.variables}
                            onChange={(e) => setNewTemplate(prev => ({ ...prev, variables: e.target.value }))}
                        />
                    </div>
                    
                    <div className="form-group">
                        <label>æ¸ é“é…ç½®</label>
                        <button 
                            type="button" 
                            className="btn btn-secondary" 
                            onClick={addTemplateChannel}
                        >
                            + æ·»åŠ æ¸ é“
                        </button>
                        
                        <div id="templateChannelsList" style={{ marginTop: '15px' }}>
                            {newTemplate.channels.map((channel, index) => (
                                <div key={index} className="template-channel-item">
                                    <button 
                                        className="remove-btn"
                                        onClick={() => removeTemplateChannel(index)}
                                    >
                                        âœ• ç§»é™¤
                                    </button>
                                    
                                    <div className="form-row">
                                        <div className="form-group">
                                            <label>æ¸ é“ç±»å‹</label>
                                            <select 
                                                value={channel.channelType}
                                                onChange={(e) => updateTemplateChannel(index, 'channelType', e.target.value)}
                                            >
                                                <option value="webhook">Webhook</option>
                                                <option value="telegram">Telegram</option>
                                                <option value="lark">Lark</option>
                                                <option value="slack">Slack</option>
                                                <option value="email">Email</option>
                                            </select>
                                        </div>
                                        <div className="form-group">
                                            <label>å†…å®¹ç±»å‹</label>
                                            <select 
                                                value={channel.contentType}
                                                onChange={(e) => updateTemplateChannel(index, 'contentType', e.target.value)}
                                            >
                                                <option value="text">Text</option>
                                                <option value="html">HTML</option>
                                                <option value="markdown">Markdown</option>
                                                <option value="json">JSON</option>
                                            </select>
                                        </div>
                                    </div>
                                    
                                    <div className="form-group">
                                        <label>ä¸»é¢˜æ¨¡æ¿ï¼ˆEmail æ¸ é“å¯ç”¨ï¼‰</label>
                                        <input 
                                            type="text"
                                            placeholder="Welcome {{username}}!"
                                            value={channel.subjectTemplate}
                                            onChange={(e) => updateTemplateChannel(index, 'subjectTemplate', e.target.value)}
                                        />
                                    </div>
                                    
                                    <div className="form-group">
                                        <label>å†…å®¹æ¨¡æ¿ *</label>
                                        <textarea 
                                            placeholder="ä½¿ç”¨ {{å˜é‡å}} ä½œä¸ºå ä½ç¬¦"
                                            required
                                            value={channel.contentTemplate}
                                            onChange={(e) => updateTemplateChannel(index, 'contentTemplate', e.target.value)}
                                        />
                                    </div>
                                </div>
                            ))}
                        </div>
                    </div>
                    
                    <button 
                        className="btn btn-primary" 
                        onClick={upsertTemplate}
                        disabled={!newTemplate.templateKey || !newTemplate.templateName || newTemplate.channels.length === 0}
                    >
                        ä¿å­˜æ¨¡æ¿
                    </button>
                </>
            );
        }
        
        // Logs Tab Component
        function LogsTab({ baseUrl, showResponse, apiSecret, generateGetSignature, generateSignature }) {
            const [filters, setFilters] = useState({
                userId: '',
                status: '',
                limit: '20',
                offset: '0'
            });
            const [cleanupDays, setCleanupDays] = useState('7');
            
            const getNotificationLogs = async () => {
                try {
                    const params = new URLSearchParams();
                    if (filters.userId) params.append('user_id', filters.userId);
                    if (filters.status) params.append('status', filters.status);
                    params.append('limit', filters.limit);
                    params.append('offset', filters.offset);
                    
                    const url = baseUrl + '/api/notification-logs?' + params;
                    const timestamp = Date.now().toString();
                    const signature = await generateGetSignature(timestamp, url, apiSecret);
                    
                    const response = await fetch(url, {
                        headers: {
                            'X-Timestamp': timestamp,
                            'X-Signature': signature
                        }
                    });
                    const data = await response.json();
                    showResponse(data, response.status);
                } catch (error) {
                    showResponse({ error: error.message }, 400);
                }
            };
            
            const cleanupLogs = async () => {
                if (!confirm(`ç¡®å®šè¦åˆ é™¤ ${cleanupDays} å¤©å‰çš„æ—¥å¿—å—ï¼Ÿ`)) return;
                
                try {
                    const timestamp = Date.now().toString();
                    const body = JSON.stringify({ days: parseInt(cleanupDays) });
                    const signature = await generateSignature(timestamp, body, apiSecret);
                    
                    const response = await fetch(baseUrl + '/api/notification-logs/cleanup', {
                        method: 'DELETE',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-Timestamp': timestamp,
                            'X-Signature': signature
                        },
                        body: body
                    });
                    
                    const data = await response.json();
                    showResponse(data, response.status);
                } catch (error) {
                    showResponse({ error: error.message }, 400);
                }
            };
            
            const triggerRetry = async () => {
                if (!confirm('ç¡®å®šè¦ç«‹å³è§¦å‘é‡è¯•å—ï¼Ÿ')) return;
                
                try {
                    const timestamp = Date.now().toString();
                    const body = JSON.stringify({});
                    const signature = await generateSignature(timestamp, body, apiSecret);
                    
                    const response = await fetch(baseUrl + '/api/notifications/retry', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-Timestamp': timestamp,
                            'X-Signature': signature
                        },
                        body: body
                    });
                    
                    const data = await response.json();
                    showResponse(data, response.status);
                } catch (error) {
                    showResponse({ error: error.message }, 400);
                }
            };
            
            return (
                <>
                    <h3>æŸ¥è¯¢é€šçŸ¥æ—¥å¿—</h3>
                    <div className="form-row">
                        <div className="form-group">
                            <label htmlFor="logsUserId">ç”¨æˆ· IDï¼ˆå¯é€‰ï¼‰</label>
                            <input 
                                type="text" 
                                id="logsUserId" 
                                placeholder="ç•™ç©ºæŸ¥è¯¢æ‰€æœ‰"
                                value={filters.userId}
                                onChange={(e) => setFilters(prev => ({ ...prev, userId: e.target.value }))}
                            />
                        </div>
                        <div className="form-group">
                            <label htmlFor="logsStatus">çŠ¶æ€ï¼ˆå¯é€‰ï¼‰</label>
                            <select 
                                id="logsStatus"
                                value={filters.status}
                                onChange={(e) => setFilters(prev => ({ ...prev, status: e.target.value }))}
                            >
                                <option value="">å…¨éƒ¨</option>
                                <option value="pending">å¾…å‘é€</option>
                                <option value="sent">æˆåŠŸ</option>
                                <option value="failed">å¤±è´¥</option>
                                <option value="retry">é‡è¯•ä¸­</option>
                            </select>
                        </div>
                    </div>
                    
                    <div className="form-row">
                        <div className="form-group">
                            <label htmlFor="logsLimit">æ¯é¡µæ•°é‡</label>
                            <input 
                                type="number" 
                                id="logsLimit" 
                                min="1" 
                                max="100"
                                value={filters.limit}
                                onChange={(e) => setFilters(prev => ({ ...prev, limit: e.target.value }))}
                            />
                        </div>
                        <div className="form-group">
                            <label htmlFor="logsOffset">åç§»é‡</label>
                            <input 
                                type="number" 
                                id="logsOffset" 
                                min="0"
                                value={filters.offset}
                                onChange={(e) => setFilters(prev => ({ ...prev, offset: e.target.value }))}
                            />
                        </div>
                    </div>
                    
                    <button className="btn btn-primary" onClick={getNotificationLogs}>æŸ¥è¯¢æ—¥å¿—</button>
                    
                    <hr style={{ margin: '30px 0' }} />
                    
                    <h3>æ—¥å¿—ç®¡ç†</h3>
                    <div className="form-group">
                        <label>æ¸…ç†æ—¥å¿—</label>
                        <p style={{ marginBottom: '10px', color: '#666' }}>åˆ é™¤æŒ‡å®šå¤©æ•°ä¹‹å‰çš„æ—¥å¿—è®°å½•</p>
                        <div className="form-row">
                            <div className="form-group" style={{ flex: '0.3' }}>
                                <input 
                                    type="number" 
                                    id="cleanupDays" 
                                    min="1" 
                                    placeholder="å¤©æ•°"
                                    value={cleanupDays}
                                    onChange={(e) => setCleanupDays(e.target.value)}
                                />
                            </div>
                            <div className="form-group" style={{ flex: '0.7' }}>
                                <button className="btn btn-danger" onClick={cleanupLogs}>æ¸…ç†æ—¥å¿—</button>
                            </div>
                        </div>
                    </div>
                    
                    <div className="form-group">
                        <label>è§¦å‘é‡è¯•</label>
                        <p style={{ marginBottom: '10px', color: '#666' }}>ç«‹å³è§¦å‘å¤±è´¥é€šçŸ¥çš„é‡è¯•ï¼ˆé€šå¸¸ç”±å®šæ—¶ä»»åŠ¡è‡ªåŠ¨æ‰§è¡Œï¼‰</p>
                        <button className="btn btn-primary" onClick={triggerRetry}>ç«‹å³é‡è¯•</button>
                    </div>
                </>
            );
        }
        
        // Health Tab Component
        function HealthTab({ baseUrl, showResponse }) {
            const [healthStatus, setHealthStatus] = useState(null);
            const [loading, setLoading] = useState(false);
            const [scheduledTasksStatus, setScheduledTasksStatus] = useState(null);
            
            const testHealth = async () => {
                setLoading(true);
                try {
                    const response = await fetch(baseUrl + '/health');
                    const data = await response.json();
                    showResponse(data, response.status);
                    setHealthStatus(data);
                } catch (error) {
                    showResponse({ error: error.message }, 400);
                } finally {
                    setLoading(false);
                }
            };
            
            const checkScheduledTasksHealth = async () => {
                try {
                    const response = await fetch(baseUrl + '/health/scheduled-tasks');
                    const data = await response.json();
                    showResponse(data, response.status);
                    setScheduledTasksStatus(data);
                } catch (error) {
                    showResponse({ error: error.message }, 400);
                }
            };
            
            useEffect(() => {
                testHealth();
            }, []);
            
            return (
                <>
                    <div className="endpoint-info">
                        <span className="method-badge get">GET</span>
                        <span>/health</span>
                    </div>
                    
                    <button className="btn btn-primary" onClick={testHealth} disabled={loading}>
                        {loading ? 'æ£€æŸ¥ä¸­...' : 'æ£€æŸ¥å¥åº·çŠ¶æ€'}
                    </button>
                    
                    {healthStatus && (
                        <div style={{ marginTop: '20px' }}>
                            <h4>
                                ç³»ç»ŸçŠ¶æ€: 
                                <span style={{ 
                                    marginLeft: '10px',
                                    color: healthStatus.status === 'healthy' ? '#28a745' : '#dc3545' 
                                }}>
                                    {healthStatus.status === 'healthy' ? 'âœ… å¥åº·' : 'âŒ å¼‚å¸¸'}
                                </span>
                            </h4>
                            <table className="data-table">
                                <tbody>
                                    <tr>
                                        <td><strong>ç¯å¢ƒ</strong></td>
                                        <td>{healthStatus.environment || 'production'}</td>
                                    </tr>
                                    <tr>
                                        <td><strong>æ£€æŸ¥æ—¶é—´</strong></td>
                                        <td>{new Date(healthStatus.timestamp).toLocaleString('zh-CN')}</td>
                                    </tr>
                                    {healthStatus.version && (
                                        <tr>
                                            <td><strong>ç‰ˆæœ¬</strong></td>
                                            <td>{healthStatus.version}</td>
                                        </tr>
                                    )}
                                </tbody>
                            </table>
                            
                            {healthStatus.services && (
                                <>
                                    <h4 style={{ marginTop: '20px' }}>æœåŠ¡çŠ¶æ€</h4>
                                    <table className="data-table">
                                        <thead>
                                            <tr>
                                                <th>æœåŠ¡</th>
                                                <th>çŠ¶æ€</th>
                                                <th>å»¶è¿Ÿ</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            {Object.entries(healthStatus.services).map(([service, status]) => (
                                                <tr key={service}>
                                                    <td>{service.charAt(0).toUpperCase() + service.slice(1)}</td>
                                                    <td>{status ? 'âœ… æ­£å¸¸' : 'âŒ å¼‚å¸¸'}</td>
                                                    <td>-</td>
                                                </tr>
                                            ))}
                                        </tbody>
                                    </table>
                                </>
                            )}
                        </div>
                    )}
                    
                    <hr style={{ margin: '30px 0' }} />
                    
                    <div className="endpoint-info">
                        <span className="method-badge get">GET</span>
                        <span>/health/scheduled-tasks</span>
                    </div>
                    
                    <button className="btn btn-primary" onClick={checkScheduledTasksHealth}>
                        æ£€æŸ¥å®šæ—¶ä»»åŠ¡å¥åº·çŠ¶æ€
                    </button>
                    
                    {scheduledTasksStatus && (
                        <div style={{ marginTop: '20px' }}>
                            <h4>å®šæ—¶ä»»åŠ¡çŠ¶æ€</h4>
                            <table className="data-table">
                                <thead>
                                    <tr>
                                        <th>ä»»åŠ¡åç§°</th>
                                        <th>æœ€åè¿è¡Œ</th>
                                        <th>ä¸‹æ¬¡è¿è¡Œ</th>
                                        <th>çŠ¶æ€</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    {Object.entries(scheduledTasksStatus.tasks || {}).map(([taskName, taskInfo]) => (
                                        <tr key={taskName}>
                                            <td>{taskName.replace(/_/g, ' ').toUpperCase()}</td>
                                            <td>{taskInfo.lastRun ? new Date(taskInfo.lastRun).toLocaleString('zh-CN') : 'æœªè¿è¡Œ'}</td>
                                            <td>{taskInfo.nextRun ? new Date(taskInfo.nextRun).toLocaleString('zh-CN') : '-'}</td>
                                            <td>{taskInfo.isRunning ? 'ğŸ”„ è¿è¡Œä¸­' : 'âœ… ç©ºé—²'}</td>
                                        </tr>
                                    ))}
                                </tbody>
                            </table>
                        </div>
                    )}
                </>
            );
        }
        
        // Metrics Tab Component
        function MetricsTab({ baseUrl, showResponse, apiSecret, generateGetSignature }) {
            const getMetrics = async () => {
                try {
                    const url = baseUrl + '/metrics';
                    const timestamp = Date.now().toString();
                    const signature = await generateGetSignature(timestamp, url, apiSecret);
                    
                    // è°ƒè¯•ä¿¡æ¯
                    const urlObj = new URL(url);
                    const pathAndQuery = urlObj.pathname + urlObj.search;
                    console.log('Metrics Request Debug Info:');
                    console.log('Full URL:', url);
                    console.log('Path and Query:', pathAndQuery);
                    console.log('Timestamp:', timestamp);
                    console.log('API Secret:', apiSecret);
                    console.log('Signature:', signature);
                    console.log('Payload for signature:', timestamp + pathAndQuery);
                    
                    const response = await fetch(url, {
                        headers: {
                            'X-Timestamp': timestamp,
                            'X-Signature': signature
                        }
                    });
                    const data = await response.json();
                    showResponse(data, response.status);
                } catch (error) {
                    showResponse({ error: error.message }, 400);
                }
            };
            
            return (
                <>
                    <div className="endpoint-info">
                        <span className="method-badge get">GET</span>
                        <span>/metrics</span>
                    </div>
                    
                    <button className="btn btn-primary" onClick={getMetrics}>
                        è·å–ç³»ç»ŸæŒ‡æ ‡
                    </button>
                    
                    <div style={{ marginTop: '20px', color: '#666' }}>
                        <p>ç³»ç»ŸæŒ‡æ ‡åŒ…æ‹¬ï¼š</p>
                        <ul>
                            <li>æ€»é€šçŸ¥æ•°é‡</li>
                            <li>æˆåŠŸ/å¤±è´¥ç»Ÿè®¡</li>
                            <li>æ¸ é“ä½¿ç”¨ç»Ÿè®¡</li>
                            <li>æ¨¡æ¿ä½¿ç”¨ç»Ÿè®¡</li>
                            <li>å“åº”æ—¶é—´ç»Ÿè®¡</li>
                            <li>ç³»ç»Ÿèµ„æºä½¿ç”¨æƒ…å†µ</li>
                        </ul>
                    </div>
                </>
            );
        }
        
        // Grafana Tab Component
        function GrafanaTab({ baseUrl, showResponse, environment }) {
            const [grafanaAuth, setGrafanaAuth] = useState(() => {
                const envPrefix = environment === 'production' ? 'prod_' : 'local_';
                return {
                    username: localStorage.getItem(`${envPrefix}grafana_username`) || 'grafana',
                    password: localStorage.getItem(`${envPrefix}grafana_password`) || 'test-password'
                };
            });
            
            const [grafanaPayload, setGrafanaPayload] = useState({
                receiver: 'test-user',
                channels: 'webhook',
                alertStatus: 'firing',
                useTemplate: false,
                templateKey: 'grafana-alert',
                customAlert: JSON.stringify({
                    status: 'firing',
                    labels: {
                        alertname: 'High CPU Usage',
                        severity: 'critical',
                        instance: 'server-01'
                    },
                    annotations: {
                        description: 'CPU usage is above 90%',
                        summary: 'High CPU usage detected'
                    },
                    startsAt: new Date(Date.now() - 10 * 60 * 1000).toISOString(),
                    endsAt: '0001-01-01T00:00:00Z',
                    generatorURL: 'http://grafana.example.com/alert',
                    fingerprint: '123456789'
                }, null, 2)
            });
            
            const [loading, setLoading] = useState(false);
            
            // Save auth to localStorage when changed
            const updateAuth = (field, value) => {
                const newAuth = { ...grafanaAuth, [field]: value };
                setGrafanaAuth(newAuth);
                const envPrefix = environment === 'production' ? 'prod_' : 'local_';
                localStorage.setItem(`${envPrefix}grafana_${field}`, value);
            };
            
            // Generate Grafana webhook payload
            const generatePayload = () => {
                const basePayload = {
                    receiver: grafanaPayload.receiver,
                    status: grafanaPayload.alertStatus,
                    alerts: [],
                    groupLabels: {},
                    commonLabels: {},
                    commonAnnotations: {},
                    externalURL: 'http://alertmanager.example.com',
                    version: '4',
                    groupKey: '{}:{}'
                };
                
                try {
                    const customAlert = JSON.parse(grafanaPayload.customAlert);
                    customAlert.status = grafanaPayload.alertStatus;
                    
                    if (grafanaPayload.alertStatus === 'resolved' && customAlert.endsAt === '0001-01-01T00:00:00Z') {
                        customAlert.endsAt = new Date().toISOString();
                    }
                    
                    basePayload.alerts = [customAlert];
                    basePayload.groupLabels = { alertname: customAlert.labels.alertname };
                    basePayload.commonLabels = customAlert.labels;
                    basePayload.commonAnnotations = customAlert.annotations;
                    
                    // Add template key to labels if using template
                    if (grafanaPayload.useTemplate) {
                        basePayload.commonLabels.notification_template = grafanaPayload.templateKey;
                    }
                    
                    return basePayload;
                } catch (error) {
                    console.error('Invalid alert JSON:', error);
                    return basePayload;
                }
            };
            
            // Send Grafana webhook
            const sendGrafanaWebhook = async () => {
                setLoading(true);
                try {
                    const payload = generatePayload();
                    const authString = btoa(`${grafanaAuth.username}:${grafanaAuth.password}`);
                    
                    console.log('Grafana Webhook Request:');
                    console.log('URL:', baseUrl + '/api/webhooks/grafana');
                    console.log('Auth:', authString);
                    console.log('Channels Header:', grafanaPayload.channels);
                    console.log('Payload:', JSON.stringify(payload, null, 2));
                    
                    const response = await fetch(baseUrl + '/api/webhooks/grafana', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Basic ${authString}`,
                            'X-Notification-Channels': grafanaPayload.channels
                        },
                        body: JSON.stringify(payload)
                    });
                    
                    const data = await response.json();
                    showResponse(data, response.status);
                } catch (error) {
                    showResponse({ error: error.message }, 400);
                } finally {
                    setLoading(false);
                }
            };
            
            // Preset templates
            const presetAlerts = {
                cpu: {
                    labels: {
                        alertname: 'High CPU Usage',
                        severity: 'critical',
                        instance: 'server-01',
                        job: 'node-exporter'
                    },
                    annotations: {
                        description: 'CPU usage on server-01 has been above 90% for more than 5 minutes',
                        summary: 'High CPU usage detected on production server'
                    }
                },
                memory: {
                    labels: {
                        alertname: 'High Memory Usage',
                        severity: 'warning',
                        instance: 'server-02',
                        job: 'node-exporter'
                    },
                    annotations: {
                        description: 'Memory usage is above 85%',
                        summary: 'High memory usage detected'
                    }
                },
                disk: {
                    labels: {
                        alertname: 'Disk Space Low',
                        severity: 'warning',
                        instance: 'server-03',
                        job: 'node-exporter',
                        mountpoint: '/var/lib'
                    },
                    annotations: {
                        description: 'Disk space on /var/lib is below 10%',
                        summary: 'Low disk space warning'
                    }
                },
                api: {
                    labels: {
                        alertname: 'API Response Time High',
                        severity: 'critical',
                        service: 'api-gateway',
                        endpoint: '/api/v1/users'
                    },
                    annotations: {
                        description: 'API response time is above 1000ms',
                        summary: 'High API latency detected'
                    }
                }
            };
            
            const applyPreset = (presetKey) => {
                const preset = presetAlerts[presetKey];
                const currentAlert = JSON.parse(grafanaPayload.customAlert);
                
                setGrafanaPayload(prev => ({
                    ...prev,
                    customAlert: JSON.stringify({
                        ...currentAlert,
                        labels: preset.labels,
                        annotations: preset.annotations
                    }, null, 2)
                }));
            };
            
            return (
                <>
                    <div className="endpoint-info">
                        <span className="method-badge post">POST</span>
                        <span>/api/webhooks/grafana</span>
                        <span style={{ marginLeft: '10px', color: '#666', fontSize: '14px' }}>
                            (ä½¿ç”¨ Basic Auth è®¤è¯)
                        </span>
                    </div>
                    
                    <div style={{ 
                        background: '#e3f2fd', 
                        padding: '15px', 
                        borderRadius: '6px',
                        marginBottom: '20px'
                    }}>
                        <h4 style={{ margin: '0 0 10px 0', color: '#1976d2' }}>
                            ğŸ“Š Grafana Alerting é›†æˆ
                        </h4>
                        <p style={{ margin: '0', color: '#666' }}>
                            æ­¤ç«¯ç‚¹æ¥æ”¶ Grafana Alerting çš„ webhook é€šçŸ¥ï¼Œå¹¶è½¬å‘åˆ°æŒ‡å®šçš„é€šçŸ¥æ¸ é“ã€‚
                            ä½¿ç”¨ receiver å­—æ®µä½œä¸ºç”¨æˆ· IDï¼Œæ”¯æŒè‡ªå®šä¹‰å‘Šè­¦å†…å®¹å’Œæ¨¡æ¿ã€‚
                        </p>
                    </div>
                    
                    <h3>è®¤è¯é…ç½®</h3>
                    <div className="form-row">
                        <div className="form-group">
                            <label htmlFor="grafanaUsername">ç”¨æˆ·å</label>
                            <input 
                                type="text" 
                                id="grafanaUsername"
                                value={grafanaAuth.username}
                                onChange={(e) => updateAuth('username', e.target.value)}
                                placeholder="grafana"
                            />
                        </div>
                        <div className="form-group">
                            <label htmlFor="grafanaPassword">å¯†ç </label>
                            <input 
                                type="password" 
                                id="grafanaPassword"
                                value={grafanaAuth.password}
                                onChange={(e) => updateAuth('password', e.target.value)}
                                placeholder="test-password"
                            />
                        </div>
                    </div>
                    
                    <hr style={{ margin: '30px 0' }} />
                    
                    <h3>Webhook é…ç½®</h3>
                    <div className="form-row">
                        <div className="form-group">
                            <label htmlFor="grafanaReceiver">Receiver (ç”¨æˆ· ID) *</label>
                            <input 
                                type="text" 
                                id="grafanaReceiver"
                                value={grafanaPayload.receiver}
                                onChange={(e) => setGrafanaPayload(prev => ({ ...prev, receiver: e.target.value }))}
                                placeholder="test-user"
                            />
                            <div className="quick-fill">
                                <button onClick={() => setGrafanaPayload(prev => ({ ...prev, receiver: 'test-user' }))}>
                                    æµ‹è¯•ç”¨æˆ·
                                </button>
                                <button onClick={() => setGrafanaPayload(prev => ({ ...prev, receiver: 'ops-team' }))}>
                                    è¿ç»´å›¢é˜Ÿ
                                </button>
                                <button onClick={() => setGrafanaPayload(prev => ({ ...prev, receiver: 'dev-team' }))}>
                                    å¼€å‘å›¢é˜Ÿ
                                </button>
                            </div>
                        </div>
                        <div className="form-group">
                            <label htmlFor="grafanaChannels">é€šçŸ¥æ¸ é“ (X-Notification-Channels)</label>
                            <input 
                                type="text" 
                                id="grafanaChannels"
                                value={grafanaPayload.channels}
                                onChange={(e) => setGrafanaPayload(prev => ({ ...prev, channels: e.target.value }))}
                                placeholder="webhook,telegram,lark"
                            />
                            <div className="quick-fill">
                                <button onClick={() => setGrafanaPayload(prev => ({ ...prev, channels: 'webhook' }))}>
                                    Webhook
                                </button>
                                <button onClick={() => setGrafanaPayload(prev => ({ ...prev, channels: 'webhook,telegram' }))}>
                                    Webhook + Telegram
                                </button>
                                <button onClick={() => setGrafanaPayload(prev => ({ ...prev, channels: 'webhook,lark,slack' }))}>
                                    å¤šæ¸ é“
                                </button>
                            </div>
                        </div>
                    </div>
                    
                    <div className="form-row">
                        <div className="form-group">
                            <label htmlFor="grafanaStatus">å‘Šè­¦çŠ¶æ€</label>
                            <select 
                                id="grafanaStatus"
                                value={grafanaPayload.alertStatus}
                                onChange={(e) => setGrafanaPayload(prev => ({ ...prev, alertStatus: e.target.value }))}
                            >
                                <option value="firing">ğŸ”¥ Firing (è§¦å‘)</option>
                                <option value="resolved">âœ… Resolved (æ¢å¤)</option>
                            </select>
                        </div>
                        <div className="form-group">
                            <label>
                                <input 
                                    type="checkbox"
                                    checked={grafanaPayload.useTemplate}
                                    onChange={(e) => setGrafanaPayload(prev => ({ ...prev, useTemplate: e.target.checked }))}
                                    style={{ width: 'auto', marginRight: '8px' }}
                                />
                                ä½¿ç”¨æ¨¡æ¿
                            </label>
                            {grafanaPayload.useTemplate && (
                                <select 
                                    value={grafanaPayload.templateKey}
                                    onChange={(e) => setGrafanaPayload(prev => ({ ...prev, templateKey: e.target.value }))}
                                    style={{ marginTop: '10px' }}
                                >
                                    <option value="grafana-alert">grafana-alert (é»˜è®¤)</option>
                                    <option value="grafana-alert-critical">grafana-alert-critical (ä¸¥é‡)</option>
                                    <option value="custom">è‡ªå®šä¹‰æ¨¡æ¿ Key</option>
                                </select>
                            )}
                        </div>
                    </div>
                    
                    <div className="form-group">
                        <label htmlFor="grafanaAlert">
                            å‘Šè­¦å†…å®¹ (JSON)
                            <span style={{ float: 'right', fontSize: '14px' }}>
                                é¢„è®¾æ¨¡æ¿ï¼š
                                {Object.keys(presetAlerts).map(key => (
                                    <button 
                                        key={key}
                                        onClick={() => applyPreset(key)}
                                        style={{
                                            marginLeft: '10px',
                                            padding: '2px 8px',
                                            fontSize: '12px',
                                            background: '#6c757d',
                                            color: 'white',
                                            border: 'none',
                                            borderRadius: '4px',
                                            cursor: 'pointer'
                                        }}
                                    >
                                        {key.toUpperCase()}
                                    </button>
                                ))}
                            </span>
                        </label>
                        <textarea 
                            id="grafanaAlert"
                            rows="15"
                            value={grafanaPayload.customAlert}
                            onChange={(e) => setGrafanaPayload(prev => ({ ...prev, customAlert: e.target.value }))}
                            placeholder="è¾“å…¥ Grafana å‘Šè­¦ JSON"
                            style={{ fontFamily: 'monospace', fontSize: '13px' }}
                        />
                    </div>
                    
                    <button 
                        className="btn btn-primary" 
                        onClick={sendGrafanaWebhook}
                        disabled={loading || !grafanaPayload.receiver}
                    >
                        {loading ? (
                            <>
                                <span className="loader" style={{ marginRight: '5px' }}></span>
                                å‘é€ä¸­...
                            </>
                        ) : (
                            'å‘é€ Grafana Webhook'
                        )}
                    </button>
                    
                    <hr style={{ margin: '30px 0' }} />
                    
                    <h3>ğŸ“– ä½¿ç”¨è¯´æ˜</h3>
                    <div style={{ background: '#f8f9fa', padding: '20px', borderRadius: '6px' }}>
                        <h4>Grafana Contact Point é…ç½®ç¤ºä¾‹ï¼š</h4>
                        <pre style={{ background: '#e9ecef', padding: '15px', borderRadius: '4px', overflow: 'auto' }}>
{`name: Notification System
type: webhook
settings:
  url: ${baseUrl}/api/webhooks/grafana
  httpMethod: POST
  username: ${grafanaAuth.username}
  password: <YOUR_PASSWORD>
  
  # è‡ªå®šä¹‰è¯·æ±‚å¤´
  httpHeaderName1: X-Notification-Channels
  httpHeaderValue1: webhook,telegram,lark`}
                        </pre>
                        
                        <h4 style={{ marginTop: '20px' }}>Alert Rule é…ç½®ï¼š</h4>
                        <pre style={{ background: '#e9ecef', padding: '15px', borderRadius: '4px', overflow: 'auto' }}>
{`# åœ¨ Alert Rule ä¸­è®¾ç½® receiver
# receiver ä¼šä½œä¸ºé€šçŸ¥ç³»ç»Ÿçš„ user_id
receiver: ops-team

# æˆ–è€…é’ˆå¯¹ä¸åŒå›¢é˜Ÿ
receiver: dev-team
receiver: security-team`}
                        </pre>
                        
                        <h4 style={{ marginTop: '20px' }}>æ”¯æŒçš„åŠŸèƒ½ï¼š</h4>
                        <ul style={{ paddingLeft: '20px' }}>
                            <li>âœ… å¤šå‘Šè­¦æ‰¹é‡å‘é€</li>
                            <li>âœ… Firing å’Œ Resolved çŠ¶æ€</li>
                            <li>âœ… è‡ªå®šä¹‰æ¨¡æ¿æ”¯æŒ</li>
                            <li>âœ… å¤šæ¸ é“åŒæ—¶å‘é€</li>
                            <li>âœ… å¯Œæ–‡æœ¬æ ¼å¼åŒ–</li>
                            <li>âœ… å‘Šè­¦åˆ†ç»„å’Œèšåˆ</li>
                        </ul>
                    </div>
                </>
            );
        }
        
        // Render the app
        ReactDOM.render(<App />, document.getElementById('root'));
